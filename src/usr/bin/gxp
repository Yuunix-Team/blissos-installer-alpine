#!/bin/bash

config=/etc/gxp.conf

usage() {
	cat <<EOF
usage: ${0##*/} [options]
options:
	-c <config>   use config file
	-Q [options] [package(s)]   query package(s)
	-R [options] <package(s)>   remove packge(s)
	-S [options] [package(s)]   install/update package(s)
	-U [options] <file(s)>   		install file(s)
	-h  print this help
	-j  always yes
	-k  always no
	-q  quiet mode

query options:
	-i  show package info
	-l  list installed package files
	-r  list installed repos
	-s <keyword> 	search package with one keyword

remove options:
	-d  skip dependency check
	-s  remove packages and all depend on them, and/or unnecessary packages

install/update options:
	-d 	skip dependency check
	-u  upgrade
	-w  download only
	-y  sync repositories

install file options:
	-d 	skip dependency check

EOF
}

pkg_version() {
	local pkg max repo file

	while read -r pkg; do
		. "$pkg"
		if [ "$max" ] || [ "$(versionCompare "$max" "$VERSION")" = "<" ]; then
			max=$VERSION
			repo=$(echo pkg | sed -E "s|$GXP_CACHE/repo/(.*)/$pkg|\1|")
			file=$FILEONHOST
		fi
		unset NAME VERSION DESC ARCH LICENSE AUTHOR URL PROVIDES DEPENDS FILEONHOST
	done <<<"$(find "$GXP_CACHE/repo/" -type "f" -maxdepth "2" -iname "$1")"
	echo "$repo $max $file"
}

pkg_deplist() {
	[ "$nodepcheck" = true ] && return

	local deps pkg oldver subdeps

	. "$GXP_CACHE/repo/$(pkg_version "$1" | awk '{print $1}')/$1"

	for pkg in $DEPENDS; do
		oldver=$(sed -n "s/VERSION=//p" "$GXP_DB/$NAME/info")
		case "$(versionCompare "$oldver" "$VERSION")" in
		"<") deps="$deps $NAME" ;;
		esac
	done

	unset NAME VERSION DESC ARCH LICENSE AUTHOR URL PROVIDES DEPENDS FILEONHOST

	for pkg in $deps; do
		subdeps="$subdeps $(pkg_deplist "$pkg")"
	done

	echo "$subdeps $deps"
}

versionCompare() {
	subVersion() {
		echo -e "${1%%"."*}"
	}
	cutDot() {
		local offset=${#1}
		local length=${#2}
		echo -e "${2:((++offset)):length}"
	}
	if [ -z "${1}" ] || [ -z "${2}" ]; then
		echo "=" && exit 0
	fi
	local v1
	v1=$(echo -e "${1}" | tr -d '[:space:]')
	local v2
	v2=$(echo -e "${2}" | tr -d '[:space:]')
	local v1Sub
	v1Sub=$(subVersion "$v1")
	local v2Sub
	v2Sub=$(subVersion "$v2")
	if ((v1Sub > v2Sub)); then
		echo ">"
	elif ((v1Sub < v2Sub)); then
		echo "<"
	else
		versionCompare "$(cutDot "$v1Sub" "$v1")" "$(cutDot "$v2Sub" "$v2")"
	fi
}

refreshdb() {
	local repo reponame fetched_repo
	for repo in /etc/gxp.d/*; do
		reponame=${repo##*/}
		fetched_repo=$("$GEARLIB"/gxp/fetch "$reponame" repo.db) ||
			echo "Failed to update repo '$reponame'" && continue
		tar -xaf "$fetched_repo" -C "$GXP_CACHE/repo/$reponame/"
		rm -f "$fetched_repo"
	done
}

query() {
	print_pkginfo() {
		local importfile searchdir searchtype depth type=$1 key=$2 pkg oldver
		case "$type" in
		online)
			importfile=
			searchdir=$GXP_CACHE/repo/
			searchtype=f
			depth=2
			STATUS="Not installed"
			;;
		*)
			importfile=/info
			searchdir=$GXP_DB
			searchtype=d
			depth=1
			STATUS="Installed"
			;;
		esac

		while read -r pkg; do
			. "$pkg$importfile"

			if [ "$type" = online ] && [ -d "$GXP_DB/$NAME" ]; then
				oldver=$(sed -n "s/VERSION=//p" "$GXP_DB/$NAME/info")
				case "$(versionCompare "$oldver" "$VERSION")" in
				">" | "=") continue ;;
				esac
			fi

			if [ "$info" ]; then
				if [ "$type" = online ]; then
					echo "$NAME $VERSION"
				else
					echo "$NAME $VERSION [Installed]"
				fi
			else
				cat <<EOF
Package: $NAME
Version: $VERSION
Status: $STATUS
Desctiption: $DESC
Architecture: $ARCH
License: $LICENSE
Packager: $AUTHOR
URL: $URL
Provides: $PROVIDES
Depends on: $DEPENDS
EOF
			fi

			if [ "$mode" != search ] && [ "$type" != online ] && [ "$filelist" ]; then
				echo "Installed files:"
				cat "$GXP_DB/$NAME/files"
				echo
			fi

			unset NAME VERSION DESC ARCH LICENSE AUTHOR URL PROVIDES DEPENDS FILEONHOST
		done <<<"$(find "$searchdir" -type "$searchtype" -maxdepth "$depth" -iname "$2")"
	}

	case "$mode" in
	repo)
		local repo
		for repo in /etc/gxp.d/*; do
			. "$repo"
			echo
			echo "Repo description: $DESC"
			echo "Repo mirror list: $SERVERS"
			echo
			unset DESC SERVERS
		done
		return
		;;
	search)
		local pkg STATUS

		print_pkginfo "online" "*${keyword,,}*"
		print_pkginfo "not" "*${keyword,,}*"

		return
		;;
	esac

	local valid_pkgs

	while [ "$1" ]; do
		if [ -d "$GXP_DB/${1,,}" ] || find "$GXP_CACHE/repo/" -type f -name "${1,,}"; then
			valid_pkgs="$valid_pkgs ${1,,}"
		else
			echo "Invalid package: '$1'"
		fi
		shift
	done

	for pkg in $valid_pkgs; do
		print_pkginfo "online" "$pkg"
		print_pkginfo "not" "$pkg"
	done
}

remove() {
	echo
}

sync() {
	local dl_pkgs pkg pkgname newver

	if [ "$refresh" = true ]; then
		refreshdb
		[ "$1" ] || return
	fi

	while [ "$1" ]; do
		case "$1" in
		*/*)
			echo "Invalid package '$1'"
			continue
			;;
		esac
		dl_pkgs="$dl_pkgs $(pkg_deplist "${1,,}") ${1,,}"
		shift
	done

	if [ "$upgrade" = true ]; then
		for pkg in "$GXP_DB"/*/; do
			pkgname=${pkg##*/}
			newver=

			echo "$dl_pkgs" | grep "$pkgname" &&
				continue

			. "$pkg"/info
			newver=$(pkg_version "$pkgname" | awk '{print $2}')
			[ "$(versionCompare "$VERSION" "$newver")" = "<" ] &&
				dl_pkgs="$dl_pkgs $pkgname"

			unset VERSION
		done
		unset NAME DESC ARCH LICENSE AUTHOR URL PROVIDES DEPENDS FILEONHOST
	fi

	echo "Total packages to download: $dl_pkgs"

	case "$mode" in
	sync) if [ "$always" ]; then
		echo "$always" | "$GEARLIB"/gxp/install "$dl_pkgs"
	else
		"$GEARLIB"/gxp/install "$dl_pkgs"
	fi ;;
	download)
		case "$always" in
		y) ;;
		n) return ;;
		*)
			read -rn 1 -p "Confirm? [Y/n]" confirm
			case "$confirm" in
			[Yy]) ;;
			*) return ;;
			esac
			;;
		esac
		local fetched
		for pkg in $dl_pkgs; do
			fetched=$(pkg_version "$pkg")
			"$GEARLIB"/gxp/fetch "$(echo "$fetched" | awk '{print $1}')" "$(echo "$fetched" | awk '{print $3}')"
		done
		;;
	esac
}

insfile() {
	local pkg list fname oldpwd
	for pkg in "$@"; do
		if echo "$pkg" | grep -E "^[a-z]+://"; then
			fname=${pkg##*/}
			oldpwd=$(pwd)
			cd "$GXP_CACHE/pkg"
			curl -LO "$pkg" ||
				wget "$pkg" ||
				echo "Failed to fetch '$pkg'" && cd "$oldpwd" && return 1
			cd "$oldpwd"
			list="$list $GXP_CACHE/pkg/$fname"
		else
			list="$list $pkg"
		fi
	done

	"$GEARLIB"/gxp/parse "$list"
}

while getopts "c:hjkqQRSU" opt; do
	case "$opt" in
	c) config=$OPTARG ;;
	h) usage && exit ;;
	j) always=y ;;
	k) always=n ;;
	q) quiet=true ;;
	Q)
		mode=index
		while getopts "ilrs:" subopt; do
			case "$subopt" in
			i) info=true ;;
			l) filelist=true ;;
			r) mode=repo ;;
			s) mode=search && keyword=$OPTARG ;;
			*) usage && exit 1 ;;
			esac
		done
		shift $((OPTIND - 1))
		. "$(readlink -f "$config")"
		query $@
		;;
	R)
		while getopts "ds" subopt; do
			case "$subopt" in
			d) nodepcheck=true ;;
			s) clean=true ;;
			*) usage && exit 1 ;;
			esac
		done
		shift $((OPTIND - 1))
		. "$(readlink -f "$config")"
		remove $@
		;;
	S)
		mode=sync
		while getopts "duwy" subopt; do
			case "$subopt" in
			d) nodepcheck=true ;;
			u) upgrade=true ;;
			w) mode=download ;;
			y) refresh=true ;;
			*) usage && exit 1 ;;
			esac
		done
		shift $((OPTIND - 1))
		. "$(readlink -f "$config")"
		sync $@
		;;
	U)
		while getopts "d" subopt; do
			case "$subopt" in
			d) nodepcheck=true ;;
			*) usage && exit 1 ;;
			esac
			shift $((OPTIND - 1))
			. "$(readlink -f "$config")"
			insfile $@
		done
		;;
	*) usage && exit 1 ;;
	esac
done
